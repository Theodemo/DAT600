# Table des matières

## Introduction

## 1. Le rôle des algorithmes en informatique

Les algorithmes jouent un rôle fondamental dans le domaine de l'informatique. Ils permettent de résoudre des problèmes de manière systématique et efficace, et constituent l'essence de la programmation. Comprendre ce qu'est un algorithme et comment il est utilisé dans la technologie moderne est essentiel pour tout informaticien.

### 1.1 Algorithmes

Un **algorithme** est une suite finie et non ambiguë d'instructions permettant de résoudre un problème ou d'accomplir une tâche. Il doit avoir les caractéristiques suivantes :

- **Finitude** : L'algorithme doit se terminer après un nombre fini d'étapes.
- **Définition précise** : Chaque étape de l'algorithme doit être clairement définie.
- **Entrées** : L'algorithme peut avoir zéro ou plusieurs entrées.
- **Sorties** : Il doit produire au moins une sortie.
- **Efficacité** : L'algorithme doit être suffisamment efficace pour être utilisable en pratique.

Les algorithmes sont indépendants du langage de programmation. Ils peuvent être exprimés en pseudo-code, en diagrammes de flux, ou en langage naturel formalisé avant d'être traduits en code exécutable.

Exemples classiques d'algorithmes :

- Recherche linéaire
- Recherche binaire
- Tri par insertion
- Tri rapide

### 1.2 Les algorithmes comme technologie

Les algorithmes ne sont pas simplement des outils théoriques : ils sont au cœur des **technologies modernes**. Leur efficacité influence la performance des logiciels, la réactivité des systèmes en temps réel, et la faisabilité de tâches complexes.

Quelques domaines où les algorithmes sont cruciaux :

- **Traitement de données massives (Big Data)** : Des algorithmes efficaces sont essentiels pour traiter des pétaoctets de données.
- **Cryptographie** : Les algorithmes de chiffrement protègent les données sensibles dans les communications.
- **Apprentissage automatique (Machine Learning)** : Les algorithmes apprennent à partir de données pour faire des prédictions ou des classifications.
- **Optimisation** : Des algorithmes sont utilisés pour allouer des ressources, planifier des itinéraires, ou résoudre des problèmes complexes d’organisation.
- **Recherche sur le web** : Les moteurs de recherche comme Google reposent sur des algorithmes sophistiqués pour classer les pages web.

En tant que technologie, les algorithmes sont constamment améliorés pour gérer des volumes de données croissants, répondre à des exigences en temps réel, et offrir des résultats plus précis et pertinents. L'ingénierie algorithmique est devenue un domaine à part entière dans le développement logiciel et la recherche en informatique.

## 2. Premiers pas avec les algorithmes 17
### 2.1 Tri par insertion
### 2.2 Analyse des algorithmes
### 2.3 Conception des algorithmes

## 3. Caractérisation des temps d'exécution 49
### 3.1 Notation O, Y et Θ
### 3.2 Notations asymptotiques : définitions formelles
### 3.3 Notations standards et fonctions communes

## 4. Diviser pour régner 76
### 4.1 Multiplication de matrices carrées
### 4.2 Algorithme de Strassen pour la multiplication de matrices
### 4.3 Méthode de substitution pour résoudre les récurrences
### 4.4 Méthode de l'arbre de récurrence
### 4.5 Méthode maître pour résoudre les récurrences
### 4.6 Preuve du théorème maître continu
### 4.7 Récurrences Akra###Bazzi

## 5. Analyse probabiliste et algorithmes randomisés 126
### 5.1 Le problème de l'embauche
### 5.2 Variables aléatoires indicatrices
### 5.3 Algorithmes randomisés
### 5.4 Analyse probabiliste et autres usages des variables aléatoires indicatrices

#########

## II. Tri et statistiques d'ordre

### Introduction 157

## 6. Tri par tas (Heapsort) 161
### 6.1 Tas
### 6.2 Maintien de la propriété du tas
### 6.3 Construction d'un tas
### 6.4 Algorithme Heapsort
### 6.5 Files de priorité

## 7. Tri rapide (Quicksort) 182
### 7.1 Description du tri rapide
### 7.2 Performance du tri rapide
### 7.3 Version randomisée du tri rapide
### 7.4 Analyse du tri rapide

## 8. Tri en temps linéaire 205
### 8.1 Bornes inférieures pour le tri
### 8.2 Tri par comptage
### 8.3 Tri radix
### 8.4 Tri par seau

## 9. Médians et statistiques d'ordre 227
### 9.1 Minimum et maximum
### 9.2 Sélection en temps linéaire moyen
### 9.3 Sélection en temps linéaire dans le pire des cas

#########

## III. Structures de données

### Introduction 249

## 10. Structures de données élémentaires 252
### 10.1 Structures de données basées sur des tableaux : tableaux, matrices, piles, files
### 10.2 Listes chaînées
### 10.3 Représentation des arbres enracinés

## 11. Tables de hachage 272
### 11.1 Tables d'adresses directes
### 11.2 Tables de hachage
### 11.3 Fonctions de hachage
### 11.4 Résolution par adressage ouvert
### 11.5 Considérations pratiques

## 12. Arbres binaires de recherche 312
### 12.1 Qu'est###ce qu'un arbre binaire de recherche ?
### 12.2 Interrogation d'un arbre binaire de recherche
### 12.3 Insertion et suppression

## 13. Arbres rouges###noirs 331
### 13.1 Propriétés des arbres rouges###noirs
### 13.2 Rotations
### 13.3 Insertion
### 13.4 Suppression

#########

## IV. Techniques avancées de conception et d'analyse

### Introduction 361

## 14. Programmation dynamique 362
### 14.1 Coupe de tiges
### 14.2 Multiplication de chaînes de matrices
### 14.3 Éléments de la programmation dynamique
### 14.4 Plus longue sous###séquence commune
### 14.5 Arbres de recherche binaires optimaux

## 15. Algorithmes gloutons 417
### 15.1 Problème de sélection d'activités
### 15.2 Éléments de la stratégie gloutonne
### 15.3 Codes de Huffman
### 15.4 Mise en cache hors ligne

## 16. Analyse amortie 448
### 16.1 Analyse agrégée
### 16.2 La méthode de comptabilité
### 16.3 La méthode potentielle
### 16.4 Tables dynamiques

#########

## V. Structures de données avancées

### Introduction 477

## 17. Augmentation des structures de données 480
### 17.1 Statistiques d'ordre dynamiques
### 17.2 Comment augmenter une structure de données
### 17.3 Arbres d'intervalles

## 18. Arbres B 497
### 18.1 Définition des arbres B
### 18.2 Opérations de base sur les arbres B
### 18.3 Suppression d'une clé dans un arbre B

## 19. Structures de données pour ensembles disjoints 520
### 19.1 Opérations sur les ensembles disjoints
### 19.2 Représentation par listes chaînées des ensembles disjoints
### 19.3 Forêts d'ensembles disjoints
### 19.4 Analyse de l'union par rang avec compression de chemin

#########

## VI. Algorithmes sur les graphes

### Introduction 547

## 20. Algorithmes élémentaires sur les graphes 549
### 20.1 Représentation des graphes
### 20.2 Recherche en largeur (BFS)
### 20.3 Recherche en profondeur (DFS)
### 20.4 Tri topologique
### 20.5 Composantes fortement connexes

## 21. Arbres couvrants minimaux 585
### 21.1 Construction d'un arbre couvrant minimal
### 21.2 Algorithmes de Kruskal et Prim

## 22. Chemins les plus courts à partir d'une source 604
### 22.1 L'algorithme de Bellman-Ford
### 22.2 Chemins les plus courts dans les graphes acycliques dirigés
### 22.3 L'algorithme de Dijkstra

## 23. Chemins les plus courts pour toutes les paires 646
### 23.1 Chemins les plus courts et multiplication de matrices
### 23.2 L'algorithme de Floyd-Warshall
### 23.3 L'algorithme de Johnson pour les graphes épars

## 24. Flot maximum 670
### 24.1 Réseaux de flot
### 24.2 Méthode de Ford###Fulkerson
### 24.3 Appariement bipartite maximum

#########

## VII. Sujets sélectionnés

### Introduction 745

## 26. Algorithmes parallèles 748
### 26.1 Les bases du parallélisme fork-join
### 26.2 Multiplication matricielle parallèle
### 26.3 Tri fusion parallèle

## 27. Algorithmes en ligne 791
### 27.1 Attente pour un ascenseur
### 27.2 Maintien d'une liste de recherche
### 27.3 Mise en cache en ligne
